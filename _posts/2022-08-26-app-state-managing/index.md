---
layout: post
date: 2022-08-26 10:00:00 +09:00
permalink: /2022-08-26-app-state-managing

title: '타다 드라이버 앱 상태관리 개선하기'
thumbnail:
  - color: ./thumbnail-color.png
    gray: ./thumbnail-gray.png
description: 프로덕트 생산성 및 안정성 향상을 위해 TADA Driver 애플리케이션의 상태관리 모듈을 개선한 경험의 공유


tags: ['android', 'redux', 'state']

authors:
  - name: 'Jacob Kim'
    link: https://sanggggg.me/
---

타다 드라이버 앱 상태관리 개선하기

안녕하세요, 프로덕트 생산성 및 안정성 향상을 위해 TADA Driver 애플리케이션의 상태관리 모듈을 개선한 경험의 공유

### 발단

나는 현재 타다의 Core Silo 에 있다, Core Silo 는 타 목적조직이 빠른 실험과 개선을 진행할 수 있도록 그 Base 에 해당하는 작업을 수행하는 역할도 맡고 있다.

우리 개발팀의(사실 거의 모든 개발팀의) 중요 지표의 경우, 프로덕트 자체의 안정성 상승과 프로덕트 생산성이 핵심 지표라고 할 수 있다.
- 특히 타다 드라이버 앱은 여러분들이 주로 접하는 타다 앱이 아닌, 타다 운행을 위해 택시 기사님들이 사용하는 전용 애플리케이션으로, 앱 내의 이슈 사항으로 인해 운행을 지속하지 못하게 될 경우, 실제 저희의 운행 지표에 중요한 영향 끼치거나 기사님들의 플랫폼의 신뢰도가 하락하는 큰 문제들이 발생합니다.
- 타 목적조직에서 목표를 위해 나아가기 위한 빠른 실험과 개선을 통해 프로덕트의 성숙도를 끌어올리는 과정에서 개발 속도 (프로덕트 생산성) 또한 개선해야하는 지표 중 하나 입니다.

위 두 지표를 개선하기 위해 현재 팀 내에 존재하는 문제 상황들을 분석하고, 적절한 솔루션을 찾아 해결하는 과정을 아래에 적어보려 한다.

### 팀 내에 존재하는 문제상황

#### 1. 앱 요구사항의 특성상 복잡한 상태들이 존재하지만, 이런 상태 변경을 관리하는 주체나 상태 변경으로 인한 버그의 발생이 잦다.

타다 드라이버 앱은, 일반적인 앱들에 비해 깊고 복잡한 State Tree 를 가지고 있습니다.
기본적인 앱 로그인 / 로그아웃 상태에 더해, 현재 택시를 운행중인지, 운행 중이라면 고객을 태운 상황인지, 운행과 별도로 존재하는 다음에 수행할 예약 운행이 있는지 등등...
이와 같은 깊은 (Nested & Deep) 상태를 잘 관리할 수 있도록 RIBs 라는 아키텍쳐를 선택한 것 또한 위의 상황을 잘 보여주고 있습니다.

- Interactor 에서 중앙 상태에 대해 접근하고 상태를 바꾸는 일이 빈번하다.
  - 그리고 바뀌는 이유가 항상 복합적인 버그 상황을 해결하기 위함이라 빈번하게 길어지는 주석...
- 유저 인터랙션으로 인한 상태 업데이트나 Grpc 등의 서버 드리븐 상태 업데이트 들이 직렬적으로 처리되지 못하거나
  - Atomic 한 변경이 일어나야 하지만, 연속적인 변경이 일어나는 등의 문제가 꼬여서 발생한다.
  - 유저 터치로 REST API 응답을 기다리는 중 Grpc 로 상태가 변경되면서 생기는 UX 의 어색함 등

![RIB Architecture]()

또한, 복잡한 상태를 가진 만큼 그 상태의 관리나 변경은 신중해야 하며, 도메인 지식이 충분하지 않은 상태에서는 크리티컬한 버그를 만들어 낼 가능성이 높은 버그들이 존재합니다.

```kotlin
          // 로직 참고 : https://www.notion.so/vcnccorp/CurrentForwardRide-2021-09-15-d380aa7f3e4e45e192a8657ac12fffa6
          if (currentRide?.status.isIn(RideDTO.Status.CANCELED, RideDTO.Status.DROPPED_OFF)) {
              // forward 로 교체될 예정이니 forward 에 넣어주자.
              if (ride != null) {
                  prefs.forwardRide.value = ride
              } else if (clearPendingRide) {
                  // Pending 상태에서 아직 로컬에 남아있는 Ride 는 별도의 화면이 존재하지 않기 때문에 바로 날려버린다.
                  // 이 flag 는 가능하면 Root 에서만 사용하게 될 것이다.
                  if (currentForwardRide != null && currentForwardRide.acceptedAt == null) {
                    // ...
                  }
              }
          }
```

도메인 지식이 충분하지 않은 상태에서 복잡한 상태를 변경하는 코드를 작성할 시 버그를 만들어 낼 가능성이 높고

```kotlin
fun someMutation() {
    someDataStore.driverStatus.update(someStateWhichMeanOnRiding)
    // 이 변화로 1회 상태 변화가 감지되고
    someDataStore.currentRide.update(activeRiding)
    // 이 변화로 또 한 번 상태 변화가 감지되어
}
```

Atomic 하게 일어나야 하는 상태의 변경들이 순차적인 상태 업데이트로 전달되며 각 상태 업데이트에 대해 observation 이 발생하여 동시성과 관련된 미묘한 버그를 만들어낸다던가

2. 버그 픽스 / 디버깅 시 정확한 상황을 확인하고 재현하고 싶다.
- 갑자기 콜 수락이 안 되어서 배차가 거절 당했다! -> 네트워크 응답으로 인한, 또는 기기 성능에 의존적인 동시성 이슈로 생기는 문제들은 상황을 재현하거나 발견하기 쉽지 않다.
- 개발 중에도 재현하기 힘든 상황이 존재한다. 예를 들어 1시간 전 수락한 예약을 20분 전 까지 기다렸을 때 나오는 화면
- 이런 화면은 개발할 때 최대한 상황을 유사하게 조작하여 만들기도 힘들고, 실제로 구현을 점검하기 위해서 타 팀에 공유할 때도 시간 낭비가 많다.

3. 제품 안정성 / 개발 점검 및 공유를 위한 UI 테스트를 자동화 하고 싶다.
- 타다 클라이언트 팀의 숙원인... UI 자동화 테스트를 통한 제품 안정성 높이기를 위해서 외부 환경이나 앱 내 상태를 마음대로 조작할 수 있어야 하는데, 이 것 또한 쉽지 않았다.


타다 드라이버 앱을 개발하면서 자주 발생하는 문제 상황 (백로그 리스트) 는 아래와 같았다.

## 문제 해결을 위한 사고 전개
앞서 제시된 요구사항들은 각기 다른 맥락을 가지고 있는 것 처럼 보이지만, 결국 앱 내 상태관리 라는 공통분모를 가지고 있었다. 요구사항 하나하나를 지엽적으로 해결하는 선택지도 있었겠지만, 확장가능한 해결책 제시를 위해 앱 내 상태 관리 방식을 개선하자 라는 결정을 하게 되었다.

앱 내 상태 관리 방식 개선 및 앞서 말한 요구사항 반영을 위한 장기적인 로드맵을 잡아보았다.

1. 앱 내의 상태를 관리하는 책임을 독립된 모듈로 분리하자.
2. 분리된 모듈 내에서 상태 / 상태변화를 이해하고 변경하기 쉬운 구조를 만들어 보자.
3. 관리하기 쉬워진 상태 관리 모듈을 바탕으로 / 디버깅 & 버그 픽스 효율화 / 상태 관리 방법 고도화를 진행하자.

앞으로의 글은 1, 2, 3의 과정을 설명하면서 진행하려고 한다.

# 문제 해결을 위한 코드베이스 개선 과정

## 1. 모듈의 분리
타다 클라이언트 앱의 대략적인 데이터(상태 흐름) 은 아래와 같다.
우선 이후의 과정을 위해 우리가 정의한 코어 상태에 대한 변화를 만드는 코드를 모두 한 곳으로 응집시켰고, 이전 이 상태에 대해 변화를 일으키는 코드는 전부 이 응집된 모듈을 통해 이뤄지도록 수정하였다.

이 기계적인 작업의 결과는 매우 커다랗고, 수많은 메서드를 가지고 있는 Monster Module 이 되었다.
이제 우리가 해야할 일은 퍼져있던 로직이 한데 모인 Monster Module 을 디버깅과 내부적인 책임 분리에 용이한 StateMachine 으로 만드는 일이었다.

## 2. StateMachine 의 등장 (StateMachine 이라는 용어가 생소할 수 있다)

이제야 밝히는 이야기이지만, 타다에 재직하면서 iOS, WebFrontend 등의 다양한 기술스택을 경험해 보고 있었다. 다양한 플랫폼을 돌아다니며 각기 다른 플랫폼에서 각광받는 패러다임 / 컨텍스트를 전방위적으로 이해하기 위함이었다.

그리고 이 과정에서 WebFrontend 팀의 작업을 함께 진행하며 Redux 를 사용하고 익숙해졌다.

Redux 사용하며 느낀 큰 장점들은
- Flux 로 대변되는 State Mutation(Action), State Subscription 의 개념은 기존 부터 RIBs + MVVM 으로 익숙한 사용성이다.
- 중앙집중화된 상태 머신을 제공하여 이와 궁합이 잘 맞는 커다란 State Tree 를 가지는 프로덕트 요구사항에서 Fit 이 잘 맞는다.
- 직렬화에 용이한 상태와 상태 변화(Action) 들을 바탕으로 디버깅 경험의 질을 크게 끌어올릴 수 있으며
- Middleware 들의 도입을 통해 관점 중심의 개발을 할 수 있다.
이었다.

타다 드라이버 앱의 경우, RIB 으로 대변되는 커다란 Deep Depth State Tree 를 가지고 있었기에 더욱 Redux 의 도입을 망설이지 않았고, 다른 장점들도 글의 처음에 언급한 요구사항들을 해결하는데 큰 도움이 될 수 있다고 판단했다.



```kotlin
interface StateMachine {
  val state: DataStream<State> // observable & instant get 이 가능한 내부 데이터 인터페이스
  fun dispatch(action: Action)
}

interface Reducer {
  fun reduce(prevState: State, action: Action): State
}

interface Middleware {
  fun intercept(next: (Action) -> State): (Action) -> State
}
```



## 3. StateMachine 으로 해결하는 문제

### 상태 관리의 용이

이제 StateMachine 으로 우리 앱의 상태와 상태 변화들을 직렬화 하였으니, 이를 바탕으로 앞선 문제들을 다양하게 해결할 수 있게 되었다.

초기에 제시한 문제 중 Atomic 한 상태 업데이트의 경우 Action 에 대한 State Update 가 무조건 Atomic 하게 업데이트 되므로 이에 관한 문제를 최소화 시킬 수 있다.


### Middleware 를 통해 관점 지향으로 쉽게 확장가능한 요구사항 해결
Middleware 를 통해 앞서 말한 다양한 문제들을 해결할 수 있는 방법을 적용하기 시작했다.

1. LoggerMiddleware
- 상태의 변화가 발생할 시 그 변화를 logcat 에 기록하여 상황을 손쉽게 확인할 수 있다.
2. UpdateBlockerMiddleware
- API 요청에 대한 Action 이 발생할 시, 해당 Action 과 쌍을 이루는 Response (Success or Error) Action 이 dispatch 될 때 까지 action dispatch 를 무시한다.

등이 있다. 특히 LoggerMiddleware 의 경우, 단순 상태의 업데이트를 logcat 으로 보는 것도 큰 도움이 되긴 했지만, 더욱이 이를 상태간의 diff 등을 비교하는 방식으로 어썸하게 사용하고 싶었다. 그래서 발견한 Flipper 라는 Mobile Debugger Platform 의 플러그인을 직접 구현하여 아래와 같은 디버깅 콘솔 또한 만들 수 있었다.

### 테스트 환경 조성을 위한 밑거름

StateMachine 모듈을 별도로 정의하고나서 우리가 할 수 있는 일은, 높은 도메인 지식을 가지고 있지 않다면 쉽게 건드려서는 안돼고, 심지어 잘 알아도 변경 시 쉽게 실수가 발생할 수 있는 StateMachine 를 안전하게 변경하기 위한 Unit Test 를 작성했다.

또한 전체적인 앱의 UI 가 StateMachine 의 State 에 의존하고 있으므로, 이 State 만 모킹한다면 쉽게 앱의 UI 를 표현할 수 있기에 이를 기반으로 UI Snapshot Test 를 진행할 수 있었다.

위와 같은 두 logic / UI Unit Test 를 통해서 제품에서 발생하는 신뢰도 이슈를 최소화 할 수 있을 것이라 기대하고 있다. (실제로 두 테스트를 도입한 후 프로덕션에 터지는 이슈들을 비교해 보면 재밌을 지도)


## 결론
타다 드라이버 안드로이드 코드베이스에서 발생하는 다양한 문제상황을 해결하기 위한 근본적인 해결책을 앱 내 상태 관리로 정의하고,
상태 관리 레이어 분리 / 상태 관리 방식 개선 / 실제 개선된 상태관리 방식으로 해결한 문제 상황들을 이야기 드렸다.
개인적인 회고로는 실제 안드로이드 코드베이스에서 발생하는 문제 상황 이라는 why 를 명확하게 파악하고, 필요에 의한 엔지니어링을 진행하면서 문제를 해결하는 과정이 재밌었다.
특히 그 과정에서, 막연하게 텍스트로만 느끼고 있던 Redux 스타일의 상태관리의 장/단을 체화 시킬 수 있었던 것도 큰 도움이 되었던 것 같다.

이렇게 문제 해결을 위해 기술적인 고민을 함께하고, 논리적인 판단을 바탕으로 실행에 옮기며 함께 타다 클라이언트 개발을 할 수 있는 사람을 찾고 있다.
관심 있으면 연락 달라.